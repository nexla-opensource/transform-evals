[
  {
    "task": "Flatten all nested objects consistently into top-level columns.",
    "input": {
      "id": "INC001",
      "assigned_to": {
        "id": "u1",
        "name": "Alice"
      },
      "opened_by": {
        "id": "u2",
        "name": "Bob"
      }
    },
    "output": {
      "id": "INC001",
      "assigned_to_id": "u1",
      "assigned_to_name": "Alice",
      "opened_by_id": "u2",
      "opened_by_name": "Bob"
    },
    "ground_truth_code": "def transform(data):\n    result = {}\n    \n    def flatten(obj, prefix=''):\n        for key, value in obj.items():\n            new_key = f\"{prefix}_{key}\" if prefix else key\n            if isinstance(value, dict):\n                flatten(value, new_key)\n            else:\n                result[new_key] = value\n    \n    flatten(data)\n    return result"
  },
  {
    "task": "Handle inconsistent object flattening: flatten all objects including deeper nested ones.",
    "input": {
      "id": "INC002",
      "assigned_to": {
        "id": "u1",
        "name": "Alice"
      },
      "opened_by_link": {
        "id": "u2",
        "name": "Bob"
      },
      "sys_domain_id": {
        "value": "global",
        "display_value": "Global"
      }
    },
    "output": {
      "id": "INC002",
      "assigned_to_id": "u1",
      "assigned_to_name": "Alice",
      "opened_by_link_id": "u2",
      "opened_by_link_name": "Bob",
      "sys_domain_id_value": "global",
      "sys_domain_id_display_value": "Global"
    },
    "ground_truth_code": "def transform(data):\n    result = {}\n    \n    def flatten(obj, prefix=''):\n        for key, value in obj.items():\n            new_key = f\"{prefix}_{key}\" if prefix else key\n            if isinstance(value, dict):\n                flatten(value, new_key)\n            else:\n                result[new_key] = value\n    \n    flatten(data)\n    return result"
  },
  {
    "task": "Recursively flatten nested objects with more than one level of depth.",
    "input": {
      "user": {
        "id": "u1",
        "profile": {
          "email": "a@test.com",
          "age": 30
        }
      }
    },
    "output": {
      "user_id": "u1",
      "user_profile_email": "a@test.com",
      "user_profile_age": 30
    },
    "ground_truth_code": "def transform(data):\n    result = {}\n    \n    def flatten(obj, prefix=''):\n        for key, value in obj.items():\n            new_key = f\"{prefix}_{key}\" if prefix else key\n            if isinstance(value, dict):\n                flatten(value, new_key)\n            else:\n                result[new_key] = value\n    \n    flatten(data)\n    return result"
  },
  {
    "task": "Convert array of objects into multiple rows (explode), preserving top-level data.",
    "input": {
      "order_id": "O1",
      "items": [
        {
          "sku": "S1",
          "qty": 2
        },
        {
          "sku": "S2",
          "qty": 1
        }
      ]
    },
    "output": [
      {
        "order_id": "O1",
        "items_sku": "S1",
        "items_qty": 2
      },
      {
        "order_id": "O1",
        "items_sku": "S2",
        "items_qty": 1
      }
    ],
    "ground_truth_code": "def transform(data):\n    array_field = None\n    array_data = None\n    base_data = {}\n    \n    for key, value in data.items():\n        if isinstance(value, list) and len(value) > 0 and isinstance(value[0], dict):\n            array_field = key\n            array_data = value\n        else:\n            base_data[key] = value\n    \n    if array_field is None:\n        return [data]\n    \n    result = []\n    for item in array_data:\n        row = base_data.copy()\n        for k, v in item.items():\n            row[f\"{array_field}_{k}\"] = v\n        result.append(row)\n    \n    return result"
  },
  {
    "task": "Normalize enumeration values to standard lowercase snake_case.",
    "input": {
      "id": "INC003",
      "priority": "High Priority"
    },
    "output": {
      "id": "INC003",
      "priority": "high_priority"
    },
    "ground_truth_code": "def transform(data):\n    result = data.copy()\n    for key, value in result.items():\n        if isinstance(value, str) and not key.endswith('_id') and key not in ['id', 'email']:\n            result[key] = value.lower().replace(' ', '_').replace('-', '_')\n    return result"
  },
  {
    "task": "Standardize timestamp formats to UTC ISO-8601.",
    "input": {
      "id": "INC004",
      "opened_at": "2024-01-01T10:00:00-05:00"
    },
    "output": {
      "id": "INC004",
      "opened_at": "2024-01-01T15:00:00Z"
    },
    "ground_truth_code": "def transform(data):\n    from datetime import datetime\n    result = data.copy()\n    for key, value in result.items():\n        if isinstance(value, str) and ('T' in value or 'at' in key or 'date' in key):\n            try:\n                dt = datetime.fromisoformat(value.replace('Z', '+00:00'))\n                result[key] = dt.strftime('%Y-%m-%dT%H:%M:%SZ') if dt.utcoffset() else value\n                if dt.utcoffset():\n                    utc_dt = dt.utctimetuple()\n                    from datetime import timezone\n                    result[key] = datetime(*utc_dt[:6], tzinfo=timezone.utc).strftime('%Y-%m-%dT%H:%M:%SZ')\n            except:\n                pass\n    return result"
  },
  {
    "task": "Coerce numeric-like strings into integer types.",
    "input": {
      "id": "INC005",
      "retry_count": "3"
    },
    "output": {
      "id": "INC005",
      "retry_count": 3
    },
    "ground_truth_code": "def transform(data):\n    result = {}\n    for key, value in data.items():\n        if isinstance(value, str) and value.isdigit():\n            result[key] = int(value)\n        else:\n            result[key] = value\n    return result"
  },
  {
    "task": "Normalize boolean-like values (e.g., 'yes', 'no') to strict true/false.",
    "input": {
      "id": "INC006",
      "active": "yes"
    },
    "output": {
      "id": "INC006",
      "active": true
    },
    "ground_truth_code": "def transform(data):\n    bool_map = {\n        'yes': True, 'no': False,\n        'true': True, 'false': False,\n        '1': True, '0': False,\n        'y': True, 'n': False\n    }\n    result = {}\n    for key, value in data.items():\n        if isinstance(value, str) and value.lower() in bool_map:\n            result[key] = bool_map[value.lower()]\n        else:\n            result[key] = value\n    return result"
  },
  {
    "task": "Create a derived field from existing columns (e.g., extract domain from email).",
    "input": {
      "id": "INC007",
      "email": "user@example.com"
    },
    "output": {
      "id": "INC007",
      "email": "user@example.com",
      "email_domain": "example.com"
    },
    "ground_truth_code": "def transform(data):\n    result = data.copy()\n    if 'email' in result and isinstance(result['email'], str) and '@' in result['email']:\n        result['email_domain'] = result['email'].split('@')[1]\n    return result"
  },
  {
    "task": "Handle missing optional fields without dropping rows.",
    "input": {
      "id": "INC008",
      "description": null
    },
    "output": {
      "id": "INC008",
      "description": null
    },
    "ground_truth_code": "def transform(data):\n    return data.copy()"
  },
  {
    "task": "Apply lookup-based enrichment mapping codes to human-readable labels.",
    "input": {
      "id": "INC009",
      "status_code": 2
    },
    "output": {
      "id": "INC009",
      "status_code": 2,
      "status_label": "in_progress"
    },
    "ground_truth_code": "def transform(data):\n    status_lookup = {\n        1: \"new\",\n        2: \"in_progress\",\n        3: \"resolved\",\n        4: \"closed\"\n    }\n    result = data.copy()\n    if 'status_code' in result:\n        result['status_label'] = status_lookup.get(result['status_code'], 'unknown')\n    return result"
  },
  {
    "task": "Ensure final output contains no nested objects or arrays.",
    "input": {
      "id": "INC010",
      "metadata": {
        "source": "api",
        "version": "v1"
      }
    },
    "output": {
      "id": "INC010",
      "metadata_source": "api",
      "metadata_version": "v1"
    },
    "ground_truth_code": "def transform(data):\n    result = {}\n    \n    def flatten(obj, prefix=''):\n        for key, value in obj.items():\n            new_key = f\"{prefix}_{key}\" if prefix else key\n            if isinstance(value, dict):\n                flatten(value, new_key)\n            else:\n                result[new_key] = value\n    \n    flatten(data)\n    return result"
  },
  {
    "task": "Handle polymorphic field types with consistent type normalization (string to array).",
    "input": {
      "id": "INC011",
      "hobbies": "reading"
    },
    "output": {
      "id": "INC011",
      "hobbies": [
        "reading"
      ]
    },
    "ground_truth_code": "def transform(data):\n    result = data.copy()\n    if 'hobbies' in result and isinstance(result['hobbies'], str):\n        result['hobbies'] = [result['hobbies']]\n    return result"
  },
  {
    "task": "Convert numeric formats with comma thousand separators.",
    "input": {
      "id": "INC012",
      "revenue": "1,234.56"
    },
    "output": {
      "id": "INC012",
      "revenue": 1234.56
    },
    "ground_truth_code": "def transform(data):\n    result = {}\n    for key, value in data.items():\n        if isinstance(value, str) and ',' in value:\n            try:\n                result[key] = float(value.replace(',', ''))\n            except:\n                result[key] = value\n        else:\n            result[key] = value\n    return result"
  },
  {
    "task": "Handle corrupted numeric fields gracefully with data quality flags.",
    "input": {
      "id": "INC013",
      "count": "N/A"
    },
    "output": {
      "id": "INC013",
      "count": null,
      "data_quality_flag": "invalid_count"
    },
    "ground_truth_code": "def transform(data):\n    result = data.copy()\n    if 'count' in result:\n        if isinstance(result['count'], str) and not result['count'].replace('.', '').replace('-', '').isdigit():\n            result['count'] = None\n            result['data_quality_flag'] = 'invalid_count'\n    return result"
  },
  {
    "task": "Handle empty arrays by converting to None.",
    "input": {
      "id": "INC014",
      "tags": []
    },
    "output": {
      "id": "INC014",
      "tags": null
    },
    "ground_truth_code": "def transform(data):\n    result = {}\n    for key, value in data.items():\n        if isinstance(value, list) and len(value) == 0:\n            result[key] = None\n        else:\n            result[key] = value\n    return result"
  },
  {
    "task": "Deduplicate records based on composite keys, keeping latest.",
    "input": [
      {
        "user_id": "u1",
        "product_id": "p1",
        "timestamp": "2024-01-01T10:00:00Z"
      },
      {
        "user_id": "u1",
        "product_id": "p1",
        "timestamp": "2024-01-01T11:00:00Z"
      }
    ],
    "output": [
      {
        "user_id": "u1",
        "product_id": "p1",
        "timestamp": "2024-01-01T11:00:00Z"
      }
    ],
    "ground_truth_code": "def transform(data):\n    if not isinstance(data, list):\n        return data\n    \n    seen = {}\n    for record in data:\n        key = (record.get('user_id'), record.get('product_id'))\n        if key not in seen or record.get('timestamp', '') > seen[key].get('timestamp', ''):\n            seen[key] = record\n    \n    return list(seen.values())"
  },
  {
    "task": "Pivot array of key-value pairs into individual columns.",
    "input": {
      "id": "INC015",
      "attributes": [
        {
          "key": "color",
          "value": "red"
        },
        {
          "key": "size",
          "value": "large"
        }
      ]
    },
    "output": {
      "id": "INC015",
      "attr_color": "red",
      "attr_size": "large"
    },
    "ground_truth_code": "def transform(data):\n    result = {}\n    for key, value in data.items():\n        if key == 'attributes' and isinstance(value, list):\n            for item in value:\n                if isinstance(item, dict) and 'key' in item and 'value' in item:\n                    result[f\"attr_{item['key']}\"] = item['value']\n        else:\n            result[key] = value\n    return result"
  },
  {
    "task": "Normalize phone numbers to E.164 format (US numbers).",
    "input": {
      "id": "INC017",
      "phone": "(555) 123-4567"
    },
    "output": {
      "id": "INC017",
      "phone": "+15551234567"
    },
    "ground_truth_code": "def transform(data):\n    import re\n    result = data.copy()\n    if 'phone' in result:\n        digits = re.sub(r'\\D', '', result['phone'])\n        if len(digits) == 10:\n            result['phone'] = f\"+1{digits}\"\n    return result"
  },
  {
    "task": "Split delimited string fields into arrays.",
    "input": {
      "id": "INC022",
      "categories": "electronics,gadgets,smartphones"
    },
    "output": {
      "id": "INC022",
      "categories": [
        "electronics",
        "gadgets",
        "smartphones"
      ]
    },
    "ground_truth_code": "def transform(data):\n    result = data.copy()\n    if 'categories' in result and isinstance(result['categories'], str):\n        result['categories'] = [cat.strip() for cat in result['categories'].split(',')]\n    return result"
  },
  {
    "task": "Aggregate array of metrics into summary statistics.",
    "input": {
      "id": "INC020",
      "daily_sales": [
        {
          "date": "2024-01-01",
          "amount": 100
        },
        {
          "date": "2024-01-02",
          "amount": 150
        },
        {
          "date": "2024-01-03",
          "amount": 200
        }
      ]
    },
    "output": {
      "id": "INC020",
      "total_sales": 450,
      "avg_daily_sales": 150,
      "max_daily_sales": 200,
      "min_daily_sales": 100,
      "sales_days": 3
    },
    "ground_truth_code": "def transform(data):\n    result = {'id': data['id']}\n    if 'daily_sales' in data:\n        amounts = [item['amount'] for item in data['daily_sales']]\n        result['total_sales'] = sum(amounts)\n        result['avg_daily_sales'] = sum(amounts) // len(amounts)\n        result['max_daily_sales'] = max(amounts)\n        result['min_daily_sales'] = min(amounts)\n        result['sales_days'] = len(amounts)\n    return result"
  },
  {
    "task": "Parse JSON string fields into structured data.",
    "input": {
      "id": "INC026",
      "config": "{\"debug\": true, \"timeout\": 30}"
    },
    "output": {
      "id": "INC026",
      "config_debug": true,
      "config_timeout": 30
    },
    "ground_truth_code": "def transform(data):\n    import json\n    result = {}\n    for key, value in data.items():\n        if key == 'config' and isinstance(value, str):\n            try:\n                config_data = json.loads(value)\n                for k, v in config_data.items():\n                    result[f\"{key}_{k}\"] = v\n            except:\n                result[key] = value\n        else:\n            result[key] = value\n    return result"
  },
  {
    "task": "Normalize case-insensitive enum values.",
    "input": {
      "id": "INC027",
      "status": "In-Progress"
    },
    "output": {
      "id": "INC027",
      "status": "in_progress"
    },
    "ground_truth_code": "def transform(data):\n    result = data.copy()\n    if 'status' in result and isinstance(result['status'], str):\n        result['status'] = result['status'].lower().replace('-', '_').replace(' ', '_')\n    return result"
  },
  {
    "task": "Handle null propagation in derived calculations.",
    "input": {
      "id": "INC028",
      "quantity": null,
      "price": 10.0
    },
    "output": {
      "id": "INC028",
      "quantity": null,
      "price": 10.0,
      "total": null
    },
    "ground_truth_code": "def transform(data):\n    result = data.copy()\n    if 'quantity' in result and 'price' in result:\n        if result['quantity'] is None or result['price'] is None:\n            result['total'] = None\n        else:\n            result['total'] = result['quantity'] * result['price']\n    return result"
  },
  {
    "task": "Standardize inconsistent date formats to ISO format.",
    "input": {
      "id": "INC033",
      "date1": "01/15/2024",
      "date2": "2024-01-15",
      "date3": "15-Jan-2024"
    },
    "output": {
      "id": "INC033",
      "date1": "2024-01-15",
      "date2": "2024-01-15",
      "date3": "2024-01-15"
    },
    "ground_truth_code": "def transform(data):\n    from datetime import datetime\n    result = {}\n    for key, value in data.items():\n        if isinstance(value, str) and any(c in value for c in ['/', '-']) and key.startswith('date'):\n            try:\n                for fmt in ['%m/%d/%Y', '%Y-%m-%d', '%d-%b-%Y']:\n                    try:\n                        dt = datetime.strptime(value, fmt)\n                        result[key] = dt.strftime('%Y-%m-%d')\n                        break\n                    except:\n                        continue\n                else:\n                    result[key] = value\n            except:\n                result[key] = value\n        else:\n            result[key] = value\n    return result"
  },
  {
    "task": "Apply conditional transformations based on field values (pricing rules).",
    "input": {
      "id": "INC034",
      "type": "premium",
      "base_price": 100
    },
    "output": {
      "id": "INC034",
      "type": "premium",
      "base_price": 100,
      "final_price": 90,
      "discount_applied": 10
    },
    "ground_truth_code": "def transform(data):\n    result = data.copy()\n    if 'type' in result and 'base_price' in result:\n        if result['type'] == 'premium':\n            discount = result['base_price'] * 0.1\n            result['discount_applied'] = int(discount)\n            result['final_price'] = int(result['base_price'] - discount)\n    return result"
  },
  {
    "task": "Calculate running totals within groups (window function).",
    "input": [
      {
        "user_id": "u1",
        "date": "2024-01-01",
        "amount": 10
      },
      {
        "user_id": "u1",
        "date": "2024-01-02",
        "amount": 20
      },
      {
        "user_id": "u2",
        "date": "2024-01-01",
        "amount": 15
      }
    ],
    "output": [
      {
        "user_id": "u1",
        "date": "2024-01-01",
        "amount": 10,
        "running_total": 10
      },
      {
        "user_id": "u1",
        "date": "2024-01-02",
        "amount": 20,
        "running_total": 30
      },
      {
        "user_id": "u2",
        "date": "2024-01-01",
        "amount": 15,
        "running_total": 15
      }
    ],
    "ground_truth_code": "def transform(data):\n    if not isinstance(data, list):\n        return data\n    \n    sorted_data = sorted(data, key=lambda x: (x['user_id'], x['date']))\n    result = []\n    running_totals = {}\n    \n    for record in sorted_data:\n        user_id = record['user_id']\n        if user_id not in running_totals:\n            running_totals[user_id] = 0\n        running_totals[user_id] += record['amount']\n        \n        new_record = record.copy()\n        new_record['running_total'] = running_totals[user_id]\n        result.append(new_record)\n    \n    return result"
  },
  {
    "task": "Remove special characters from text, keeping only alphanumeric and spaces.",
    "input": {
      "id": "INC031",
      "name": "Caf\u00e9 Ren\u00e9\u2014\u2122"
    },
    "output": {
      "id": "INC031",
      "name": "Caf\u00e9 Ren\u00e9"
    },
    "ground_truth_code": "def transform(data):\n    import re\n    result = data.copy()\n    if 'name' in result and isinstance(result['name'], str):\n        result['name'] = re.sub(r'[^\\w\\s]', '', result['name'], flags=re.UNICODE).strip()\n    return result"
  },
  {
    "task": "Extract fiscal quarter from date.",
    "input": {
      "id": "INC025",
      "transaction_date": "2024-03-15"
    },
    "output": {
      "id": "INC025",
      "transaction_date": "2024-03-15",
      "fiscal_year": 2024,
      "fiscal_quarter": "Q1"
    },
    "ground_truth_code": "def transform(data):\n    result = data.copy()\n    if 'transaction_date' in result:\n        year, month, day = result['transaction_date'].split('-')\n        result['fiscal_year'] = int(year)\n        month_num = int(month)\n        result['fiscal_quarter'] = f\"Q{(month_num - 1) // 3 + 1}\"\n    return result"
  },
  {
    "task": "Merge duplicate records with last-write-wins conflict resolution.",
    "input": [
      {
        "id": "u1",
        "name": "Alice",
        "email": "alice@old.com",
        "updated": "2024-01-01T10:00:00Z"
      },
      {
        "id": "u1",
        "name": "Alice Smith",
        "email": "alice@new.com",
        "updated": "2024-01-02T10:00:00Z"
      }
    ],
    "output": {
      "id": "u1",
      "name": "Alice Smith",
      "email": "alice@new.com",
      "updated": "2024-01-02T10:00:00Z"
    },
    "ground_truth_code": "def transform(data):\n    if not isinstance(data, list):\n        return data\n    \n    records_by_id = {}\n    for record in data:\n        rec_id = record['id']\n        if rec_id not in records_by_id or record['updated'] > records_by_id[rec_id]['updated']:\n            records_by_id[rec_id] = record\n    \n    return records_by_id[list(records_by_id.keys())[0]]"
  },
  {
    "task": "Detect and flag outliers in numeric data using simple threshold.",
    "input": [
      {
        "id": "t1",
        "response_time_ms": 150
      },
      {
        "id": "t2",
        "response_time_ms": 180
      },
      {
        "id": "t3",
        "response_time_ms": 5000
      }
    ],
    "output": [
      {
        "id": "t1",
        "response_time_ms": 150,
        "is_outlier": false
      },
      {
        "id": "t2",
        "response_time_ms": 180,
        "is_outlier": false
      },
      {
        "id": "t3",
        "response_time_ms": 5000,
        "is_outlier": true
      }
    ],
    "ground_truth_code": "def transform(data):\n    if not isinstance(data, list):\n        return data\n    \n    values = [r['response_time_ms'] for r in data]\n    avg = sum(values) / len(values)\n    threshold = avg * 3\n    \n    result = []\n    for record in data:\n        new_record = record.copy()\n        new_record['is_outlier'] = record['response_time_ms'] > threshold\n        result.append(new_record)\n    \n    return result"
  }
]